<p>当使用反射更改类，方法或字段的可见性以及使用反射直接更新字段值时，此规则会引起问题。 更改或绕过类，方法或字段的可访问性违反了封装原理，并可能导致运行时错误。</p>
<h2>不合规的代码示例</h2>
<pre>
class MyClass
{
    public static $publicstatic = 'Static';
    private static $privatestatic = 'private Static';
    private $private = 'Private';
    private const CONST_PRIVATE = 'Private CONST';
    public $myfield = 42;

    private function __construct() {}
    private function privateMethod() {}
    public function __set($property, $value)  {}
    public function __get($property) {}
}

$clazz = new ReflectionClass('MyClass');

$clazz-&gt;getstaticProperties(); // 不符合规定。 这样就可以访问私有静态属性

$clazz-&gt;setStaticPropertyValue('publicstatic', '42'); // 可以，因为没有过载可以绕过，并且它尊重访问控制。
$clazz-&gt;getStaticPropertyValue('publicstatic'); // 可以，因为没有过载可以绕过，并且它尊重访问控制。

// The following calls can access private or protected constants.
$clazz-&gt;getConstant('CONST_PRIVATE'); // 不合规
$clazz-&gt;getConstants(); // Noncompliant.
$clazz-&gt;getReflectionConstant('CONST_PRIVATE'); // 不合规
$clazz-&gt;getReflectionConstants(); // 不合规

$obj = $clazz-&gt;newInstanceWithoutConstructor(); // 不合规。 绕过私有构造函数。

$constructor = $clazz-&gt;getConstructor();
$constructorClosure = $constructor-&gt;getClosure($obj); // 不合规。 可以使用闭包调用私有方法。
$constructor-&gt;setAccessible(true); // 不合规。 绕过构造函数可访问性。

$prop = new ReflectionProperty('MyClass', 'private');
$prop-&gt;setAccessible(true); // 不合规。 更改属性的可访问性。
$prop-&gt;setValue($obj, "newValue"); // 不合规。 绕过__set方法。
$prop-&gt;getValue($obj); // 不合规。 绕过__get方法。

$prop2 = $clazz-&gt;getProperties()[2];
$prop2-&gt;setAccessible(true); // 不合规。 更改属性的可访问性。
$prop2-&gt;setValue($obj, "newValue"); // 不合规。 绕过__set方法。
$prop2-&gt;getValue($obj); // 不合规。 绕过__get方法。

$meth = new ReflectionMethod('MyClass', 'privateMethod');
$clos = $meth-&gt;getClosure($obj); // 不合规。 可以使用闭包调用私有方法。
$meth-&gt;setAccessible(true); // 不合规。 更改方法的可访问性。

$meth2 = $clazz-&gt;getMethods()[0];
$clos2 = $meth2-&gt;getClosure($obj); // 不合规。 可以使用闭包调用私有方法。
$meth2-&gt;setAccessible(true); // 不合规。 更改方法的可访问性。

// Using a ReflectionObject instead of the class

$objr = new ReflectionObject($obj);
$objr-&gt;newInstanceWithoutConstructor(); // 不合规。 绕过私有构造函数。

$objr-&gt;getStaticPropertyValue("publicstatic"); // 可以，因为没有过载可以绕过，并且它尊重访问控制。
$objr-&gt;setStaticPropertyValue("publicstatic", "newValue"); // 可以，因为没有过载可以绕过，并且它尊重访问控制。

$objr-&gt;getStaticProperties(); // 不合规。 这样就可以访问私有静态属性

// The following calls can access private or protected constants.
$objr-&gt;getConstant('CONST_PRIVATE'); // 不合规
$objr-&gt;getConstants(); // Noncompliant.
$objr-&gt;getReflectionConstant('CONST_PRIVATE'); // 不合规
$objr-&gt;getReflectionConstants(); // 不合规

$constructor = $objr-&gt;getConstructor();
$constructorClosure = $constructor-&gt;getClosure($obj); // 不合规。 可以使用闭包调用私有方法。
$constructor-&gt;setAccessible(true); // 不合规。 绕过构造函数可访问性。

$prop3 = $objr-&gt;getProperty('private');
$prop3-&gt;setAccessible(true); // 不合规。 更改属性的可访问性。
$prop3-&gt;setValue($obj, "newValue"); // 不合规。 绕过__set方法。
$prop3-&gt;getValue($obj); // 不合规。 绕过__get方法。

$prop4 = $objr-&gt;getProperties()[2];
$prop4-&gt;setAccessible(true); // Noncompliant. Change accessibility of a property.
$prop4-&gt;setValue($obj, "newValue"); // 不合规。 绕过__set方法。
$prop4-&gt;getValue($obj); // 不合规。 绕过__get方法。

$meth3 = $objr-&gt;getMethod('privateMethod');
$clos3 = $meth3-&gt;getClosure($obj); // 不合规。 可以使用闭包调用私有方法。
$meth3-&gt;setAccessible(true); // 不合规。 更改方法的可访问性。

$meth4 = $objr-&gt;getMethods()[0];
$clos4 = $meth4-&gt;getClosure($obj); // 不合规。 可以使用闭包调用私有方法。
$meth4-&gt;setAccessible(true); // 不合规。 更改方法的可访问性。
</pre>
<h2>See</h2>
<ul>
  <li> <a href="https://wiki.sei.cmu.edu/confluence/x/_jZGBQ">CERT, SEC05-J.</a> - 不要使用反射来增加类，方法或字段的可访问性 </li>
</ul>

